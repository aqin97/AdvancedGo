# 第一章 语言基础

## 1.3 数组、字符串和切片

### 1.3.1 数组

固定长度的特定元素的序列（0个或多个）。

- 数组的`长度`是数组的一部分，所以不同长度的数组一定不是同一类型的
- GO语言中数组是`值语义`（而非指针或引用）
- 可以将数组看成特殊的结构体，只不过数组可以通过`range操作`或者`下标索引`来访问内部数据
- `range`操作性能可能会更好，而且会保证不会出现`越界操作`
- 除了值数组之外，还可以定义字符串数组，结构体数组，函数数组，接口数组，通道数组等等
- 长度为0的数组为空数组，如：`[0]int`，在内存中不占用空间，可以用于通道的同步操作：`ch <- [0]int`，不过一般会用`struct{}`
- 数组类型是切片和字符串的基础

### 1.3.2 字符串

- 字符串的元素不可修改，是一个只读的字节数组。
- 字符串的底层结构是:

```go
type StringHeader struct {
    Data uintptr
    Len int
}
```

- 字符创其实是一个结构体，字符串的赋值过程其实就是reflect.StringHeader的复制过程，不涉及底层字节数组的复制
- 字符传虽然不是切片，但支持切片操作

### 1.3.2 切片

切片的底层数据结构有三部分，如下：

```go
type SliceHeader struct {
    Data uintptr
    Len int
    Cap int
}
```

包括指向底层数组的指针，长度和容量。

nil切片和空切片

- nil切片：底层指针指向nil，这个切片等于nil；
- 空切片：底层的指针指向一个数组，但是长度容量都是0，没有内容。

append函数的用法

- 尾部加数据：超过容量限制后，重新分配内存，并对数据进行拷贝；
- 头部加数据：大概率会重新分配内存，一般来说，往头部添加元素性能会差很多；
- append函数返回的也是一个切片，所以也支持链式操作。

以下是一个利用空切片长度为0性质的一个例子：

```go
func TrimSpace(s []byte) []byte {
    b := s[:0]
    for x := range s {
        if x != ' ' {
            b = append(b, x)
        }
    }

    return b
}
```

在使用切片时要注意可能出现的内存泄露，如：

```go
    var a []*int{ ... }
    a = a[:(len(a)-1)]
```

被删除的最后一个元素仍被引用，可能导致垃圾回收器操作被阻碍

## 1.4 函数方法和接口

函数对应操作序列，时程序的基本组成元素。GO中函数分为具名函数和匿名函数：具名函数一般对用包级函数，是匿名函数的一种特例。匿名函数引用了外部作用域中的变量时，就成了`闭包函数`，闭包函数时函数式编程语言的核心。

方法是绑定到一个具体类型的函数，GO中的方法是依托于类型的，必须在编译时静态绑定。

接口定义了方法的集合，接口对应的方法是动态绑定的。GO通过接口实现了鸭子类型。

### 1.4.1 函数

在GO语言中，函数是第一类对象（first class），可以将函数保存到变量中去。

GO的`可变参`函数的本质，实际上是切片作为函数参数的函数。

GO语言中，函数传值都是值传递，指针同样也会拷贝，只不过拷贝后的指针仍指向和原来的指针一样的地址。

在GO语言中，不需要太过于操心堆和栈的问题；同样不要假设变量在内存中的位置是固定不变的，指针随时可能发生变化。（使用CGO时不能再C语言中长期持有GO语言对象中对象的地址）。

### 1.4.2 方法

在C++中，方法对应一个类对象的成员函数，是关联到对象的具体虚表上的；
GO的方法却是关联到类型的，这样才能编译时完成静态绑定；
JAVA号称是纯粹的面向对象语言，因为JAVA中函数是不能独立存在的，每个函数都必然属于某个类。

一个面向对象的程序会用方法开表达其属性对应的操作，这样的话，使用这个对象的用户就不需要直接去操作对象，而是借助方法来完成这些事情。

面向对象更多的只是一种思想，在C语言中也存在类似的思想，我们写一段C风格的代码：

```go
//文件对象
type File struct {
    fd int
}

//打开文件
func OpenFile(name string) (f *File, err error) {
    //...
}

//关闭文件
func CloseFile(f *File) error {
    //...
}

//读取文件
func ReadFile(f *File, offset int64, data []byte) error {
    //...
}

```

其中的OpenFile类似构造函数，用于打开文件对象，CloseFile类似析构函数，用于关闭文件对象，ReadFile则是普通的成员函数。
